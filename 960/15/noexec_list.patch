--- orig/doc/man/scons.1
+++ mod/doc/man/scons.1
@@ -732,9 +732,16 @@
 of 0 means to always cache the signature, no matter how old the file is.
 
 .TP
--n, --just-print, --dry-run, --recon
-No execute.  Print the commands that would be executed to build
-any out-of-date target files, but do not execute the commands.
+-n, --no-exec, --dry-run, --recon
+No execute.  Print the targets that would be built (or cleaned if
+combined with -c) but do not execute any build commands.  Note that
+this list may not be a complete list of all targets that would be
+built (cleaned); scons can dynamically scan targets for dependencies
+but it cannot do this if the intermediate targets aren't actually
+built.  Additionally some build actions can influence subsequent build
+actions.  Therefore the list of targets generated with this option is
+approximate.
+
 
 .\" .TP
 .\" .RI -o " file" ", --old-file=" file ", --assume-old=" file


--- orig/etc/TestSCons.py
+++ mod/etc/TestSCons.py
@@ -165,35 +165,66 @@
             return None
         return env.Detect([prog])
 
-    def wrap_stdout(self, build_str = "", read_str = "", error = 0, cleaning = 0):
-        """Wraps standard output string(s) in the normal
-        "Reading ... done" and "Building ... done" strings
-        """
-        cap,lc = [ ('Build','build'),
-                   ('Clean','clean') ][cleaning]
-        if error:
-            term = "scons: %sing terminated because of errors.\n" % lc
-        else:
-            term = "scons: done %sing targets.\n" % lc
+    def wrap_stdout(self, build_str = "", read_str = "", error = 0,
+                    cleaning = 0, noexec = 0, re_match=0):
+        """Wraps standard output string(s) in the normal opening and
+        closing strings generated by SCons/Script/__init__.py for
+        building and cleaning operations."""
+
+        opening_msg, closing_msg, failure_msg = [
+
+            ('Building targets ...', 'done building targets.',
+             'building terminated because of errors.'),
+
+            ('Cleaning targets ...', 'done cleaning targets.',
+             'cleaning terminated because of errors.'),
+            
+            ('(partial) list of targets to build ...',
+             'End of target build list.',
+             'target list terminated because of errors.'),
+            
+            ('(partial) list of targets to clean ...',
+             'End of target cleaning list.',
+             'target list terminated because of errors.'),
+
+            ][ [1,0][cleaning==0] + [2,0][noexec==0] ]
+
+        if re_match:
+            opening_msg = opening_msg.replace('(', '\(').replace(')', '\)')
+
+        term = [ closing_msg, failure_msg ] [ [1,0][error==0] ]
+
+        if noexec and type(noexec) == type([]):
+            # If noexec is a list, it is a list of the targets that
+            # will echo build messages; input build_str is ignored and
+            # rewritten just for the build messages for these targets.
+            each = ['remove', 'build'] [cleaning==0] + ': '
+            build_str = each + ('\n' + each).join(noexec) + '\n'
+            
         return "scons: Reading SConscript files ...\n" + \
                read_str + \
                "scons: done reading SConscript files.\n" + \
-               "scons: %sing targets ...\n" % cap + \
+               "scons: " + opening_msg + "\n" + \
                build_str + \
-               term
+               "scons: " + term + "\n"
 
-    def up_to_date(self, options = None, arguments = None, read_str = "", **kw):
+    def up_to_date(self, options = None, arguments = None, read_str = "",
+                   noexec = 0, **kw):
         s = ""
         for arg in string.split(arguments):
             s = s + "scons: `%s' is up to date.\n" % arg
-            if options:
-                arguments = options + " " + arguments
+        if options:
+            arguments = options + " " + arguments
+        if noexec:
+            arguments = '-n ' + arguments
         kw['arguments'] = arguments
-        kw['stdout'] = self.wrap_stdout(read_str = read_str, build_str = s)
+        kw['stdout'] = self.wrap_stdout(read_str = read_str, build_str = s,
+                                        noexec=noexec)
         kw['match'] = self.match_exact
         apply(self.run, [], kw)
 
-    def not_up_to_date(self, options = None, arguments = None, **kw):
+    def not_up_to_date(self, options = None, arguments = None,
+                       noexec = 0, **kw):
         """Asserts that none of the targets listed in arguments is
         up to date, but does not make any assumptions on other targets.
         This function is most useful in conjunction with the -n option.
@@ -201,10 +232,13 @@
         s = ""
         for  arg in string.split(arguments):
             s = s + "(?!scons: `%s' is up to date.)" % arg
-            if options:
-                arguments = options + " " + arguments
+        if options:
+            arguments = options + " " + arguments
+        if noexec:
+            arguments = '-n ' + arguments
         kw['arguments'] = arguments
-        kw['stdout'] = self.wrap_stdout(build_str="("+s+"[^\n]*\n)*")
+        kw['stdout'] = self.wrap_stdout(build_str="("+s+"[^\n]*\n)*",
+                                        noexec=noexec, re_match=1)
         kw['stdout'] = string.replace(kw['stdout'],'\n','\\n')
         kw['stdout'] = string.replace(kw['stdout'],'.','\\.')
         kw['match'] = self.match_re_dotall


--- orig/src/engine/SCons/Action.py
+++ mod/src/engine/SCons/Action.py
@@ -107,8 +107,10 @@
 import SCons.Errors
 import SCons.Util
 
+display = SCons.Util.display
+
 class _Null:
-    pass
+    def __call__(self): pass
 
 _null = _Null
 
@@ -259,7 +261,41 @@
                                presub=_null,
                                show=_null,
                                execute=_null,
-                               chdir=_null):
+                               chdir=_null,
+                               got_from_cache=0):
+
+        """This is the main function that is invoked to "perform" the action.
+        target  = list of target Nodes
+        source  = list of source Nodes
+        env     = Environment for this action (for variable subst.)
+        errfunc = function to call on error (assumed to throw an exception
+                  and not return to caller).
+        presub  = True: Show action before environment variable
+                  substitution (default=presub on Action init)
+        show    = True: Show commands as they are executed (default = global
+                  print_actions value)
+        execute = True: actually execute the action (default = global
+                  execute_actions value)
+        chdir   = Dir Node to change directories to before performing
+                  Action; if True and not a Node, change directories to
+                  the directory for target[0] (default = chdir on Action init)
+        got_from_cache = True if target was already retrieved from
+                  cache; will show actual Action that would have been
+                  executed if Node was not retrieved from cache (for
+                  consistent build logs). Different from "show=True,
+                  execute=False" because this latter is a --no-exec
+                  build and just echoes nodes that would probably be
+                  built.  The latter is inexact: no targets are being
+                  built and no actions are being performed so unable
+                  to evaluate effects and results of previous actions.
+                  If node retrieved from cache, build operations are
+                  actually occurring so all dependencies and
+                  environment settings are consistent, so the node
+                  creation action can accurately be displayed.
+                  Default=0. Ignored if execute is True.
+    
+        """
+        
         if not SCons.Util.is_List(target):
             target = [target]
         if not SCons.Util.is_List(source):
@@ -281,7 +317,36 @@
             l = string.join(self.presub_lines(env), '\n  ')
             out = "Building %s with action:\n  %s\n" % (t, l)
             sys.stdout.write(out)
-        s = None
+        stat = 0
+        if execute:
+            print_func = self._show_act(target, source, env, show, chdir, save_cwd)
+            if chdir:
+                os.chdir(chdir)
+            try:
+                stat = self.execute(target, source, env)
+                if stat and errfunc:
+                    errfunc(stat)
+            finally:
+                if save_cwd:
+                    os.chdir(save_cwd)
+            print_func()
+        else:
+            if target:
+                if got_from_cache:
+                    self._show_act(target, source, env, show, chdir, save_cwd)()
+                else:
+                    if self.strfunction:
+                        display('build: ' + string.join(map(str, target),
+                                                        ' and '))
+
+        return stat
+
+    def _show_act(self, target, source, env, show, chdir, save_cwd):
+        """Shows current action about to be executed, along with any
+        chdir operation prior to the action.  Returns a function that
+        should be called after the action is built (which may show the
+        inverse chdir if needed)."""
+
         if show and self.strfunction:
             s = self.strfunction(target, source, env)
             if s:
@@ -296,20 +361,14 @@
                     if not print_func:
                         print_func = self.print_cmd_line
                 print_func(s, target, source, env)
-        stat = 0
-        if execute:
-            if chdir:
-                os.chdir(chdir)
-            try:
-                stat = self.execute(target, source, env)
-                if stat and errfunc:
-                    errfunc(stat)
-            finally:
                 if save_cwd:
-                    os.chdir(save_cwd)
-        if s and save_cwd:
-            print_func('os.chdir(%s)' % repr(save_cwd), target, source, env)
-        return stat
+                    return lambda print_func=print_func, \
+                                              save_cwd=save_cwd, \
+                                              target=target, \
+                                              source=source, \
+                                              env=env: print_func(
+                        'os.chdir(%s)' % repr(save_cwd), target, source, env)
+        return lambda target=target: _null()
 
 
 def _string_from_cmd_list(cmd_list):
@@ -454,11 +513,9 @@
     def genstring(self, target, source, env):
         return self.__generate(target, source, env, 1).genstring(target, source, env)
 
-    def __call__(self, target, source, env, errfunc=None, presub=_null,
-                 show=_null, execute=_null, chdir=_null):
+    def __call__(self, target, source, env, *args, **kw):
         act = self.__generate(target, source, env, 0)
-        return act(target, source, env, errfunc, presub,
-                   show, execute, chdir)
+        return apply(act, (target, source, env) + args, kw)
 
     def get_contents(self, target, source, env, dict=None):
         """Return the signature contents of this action's command line.
@@ -594,13 +651,32 @@
                                self.list),
                            "")
 
-    def __call__(self, target, source, env, errfunc=None, presub=_null,
-                 show=_null, execute=_null, chdir=_null):
+    def __call__(self, target, source, env, *args, **kw):
         for act in self.list:
-            stat = act(target, source, env, errfunc, presub,
-                       show, execute, chdir)
+            stat = apply(act, (target, source, env) + args, kw)
+            # If an action failed, return that status; don't execute
+            # remaining actions in the list.
             if stat:
                 return stat
+            # If this is a --no-exec build, the first action will
+            # generate a message about building the target; return now
+            # instead of generating additional messages for this same
+            # target.
+            if len(args) > 3:
+                executing = args[3]
+            elif kw.has_key('execute'):
+                executing = kw['execute']
+            else:
+                # Can't specify this as a positional argument to this
+                # function with a default unless we also explicitly
+                # list all previous positional args so that
+                # position-based calls are correct.
+                executing = _null
+            if executing == _null and not execute_actions:
+                return 0
+            if not executing:
+                return 0
+            
         return 0
 
 class ActionCaller:


--- orig/src/engine/SCons/ActionTests.py
+++ mod/src/engine/SCons/ActionTests.py
@@ -458,14 +458,14 @@
             result = a("out", "in", env)
             assert result == 0, result
             s = sio.getvalue()
-            assert s == 'execfunc(["out"], ["in"])\n', s
+            assert s == 'build: out\n', s
 
             sio = StringIO.StringIO()
             sys.stdout = sio
             result = b("out", "in", env)
             assert result == 0, result
             s = sio.getvalue()
-            assert s == 'firstfunc(["out"], ["in"])\nexecfunc(["out"], ["in"])\nlastfunc(["out"], ["in"])\n', s
+            assert s == 'build: out\n', s
 
             SCons.Action.print_actions_presub = 1
             SCons.Action.execute_actions = 1
@@ -521,7 +521,7 @@
             result = a2("out", "in", env, presub=0)
             assert result == 0, result
             s = sio.getvalue()
-            assert s == 'execfunc(["out"], ["in"])\n', s
+            assert s == 'build: out\n', s
 
             sio = StringIO.StringIO()
             sys.stdout = sio


--- orig/src/engine/SCons/Node/FS.py
+++ mod/src/engine/SCons/Node/FS.py
@@ -213,7 +213,11 @@
     t = target[0]
     cachedir, cachefile = t.cachepath()
     if t.fs.exists(cachefile):
-        return "Retrieved `%s' from cache" % t.path
+        if SCons.Action.execute_actions:
+            return "Retrieved `%s' from cache" % t.path
+        else:
+            return "build: " + string.join(map(str, target), ' and ') + \
+                   " (cached)"
     return None
 
 CacheRetrieve = SCons.Action.Action(CacheRetrieveFunc, CacheRetrieveString)
@@ -1575,7 +1579,11 @@
         if b and self.fs.CachePath:
             if self.fs.cache_show:
                 if CacheRetrieveSilent(self, [], None, execute=1) == 0:
-                    self.build(presub=0, execute=0)
+                    # Could get this from cache, but we want to show
+                    # the actual build action (unless user also
+                    # specified --no-exec).
+                    self.build(presub=0, execute=0,
+                               got_from_cache=SCons.Action.execute_actions)
                     return 1
             elif CacheRetrieve(self, [], None, execute=1) == 0:
                 return 1
@@ -1725,7 +1733,6 @@
         of its content.
 
         node - the node
-        cache - alternate node to use for the signature cache
         returns - the content signature
         """
         if calc is None:


--- orig/src/engine/SCons/Script/__init__.py
+++ mod/src/engine/SCons/Script/__init__.py
@@ -191,7 +191,8 @@
     def show(self):
         if (self.targets[0].has_builder() or self.targets[0].side_effect) \
            and not os.path.isdir(str(self.targets[0])):
-            display("Removed " + str(self.targets[0]))
+            display("remove: " + string.join(map(str, self.targets),
+                                             ' and '))
         if SCons.Environment.CleanTargets.has_key(self.targets[0]):
             files = SCons.Environment.CleanTargets[self.targets[0]]
             for f in files:
@@ -602,9 +603,9 @@
                         dest='max_drift', metavar="N",
                         help="Set maximum system clock drift to N seconds.")
 
-        self.add_option('-n', '--no-exec', '--just-print', '--dry-run',
-                        '--recon', action="store_true", dest='noexec',
-                        default=0, help="Don't build; just print commands.")
+        self.add_option('-n', '--no-exec', '--dry-run', '--recon',
+                        action="store_true", dest='noexec', default=0,
+                        help="Don't build; just print targets.")
 
         def opt_profile(option, opt, value, parser):
             global profiling
@@ -1023,6 +1024,15 @@
         failure_message = "done building targets (errors occurred during build)."
     else:
         failure_message = "building terminated because of errors."
+
+    if options.noexec:
+        opening_message = "(partial) list of targets to build ..."
+        closing_message = "End of target build list."
+        if keep_going_on_error:
+            failure_message = "done listing targets (errors occurred)."
+        else:
+            failure_message = "target list terminated because of errors."
+
     if options.question:
         task_class = QuestionTask
     try:
@@ -1034,6 +1044,15 @@
                 closing_message = "done cleaning targets (errors occurred during clean)."
             else:
                 failure_message = "cleaning terminated because of errors."
+
+            if options.noexec:
+                opening_message = "(partial) list of targets to clean ..."
+                closing_message = "End of target cleaning list."
+                if keep_going_on_error:
+                    failure_message = "done listing targets (errors occurred)."
+                else:
+                    failure_message = "target list terminated because of errors."
+
     except AttributeError:
         pass
 


--- orig/src/engine/SCons/Util.py
+++ mod/src/engine/SCons/Util.py
@@ -1303,19 +1303,28 @@
     try:
         if os.path.exists(path):
             if os.path.isfile(path):
-                if remove: os.unlink(path)
-                display("Removed " + path)
+                if remove:
+                    os.unlink(path)
+                    display("Removed " + path)
+                else:
+                    display("remove: " + path)
             elif os.path.isdir(path) and not os.path.islink(path):
                 # delete everything in the dir
                 for p in dir_index(path):
                     if os.path.isfile(p):
-                        if remove: os.unlink(p)
-                        display("Removed " + p)
+                        if remove:
+                            os.unlink(p)
+                            display("Removed " + p)
+                        else:
+                            display("remove: " + p)
                     else:
                         fs_delete(p, remove)
                 # then delete dir itself
-                if remove: os.rmdir(path)
-                display("Removed directory " + path)
+                if remove:
+                    os.rmdir(path)
+                    display("Removed directory " + path)
+                else:
+                    display("remove dir: " + path)
     except OSError, e:
         print "scons: Could not remove '%s':" % str(path), e.strerror
 


--- orig/src/engine/SCons/UtilTests.py
+++ mod/src/engine/SCons/UtilTests.py
@@ -1268,8 +1268,11 @@
               "Removed " + os.path.join(base, xxx) + '\n' + \
               "Removed directory " + base + '\n'
 
+        exp_noop = exp.replace("Removed directory", "remove dir:").replace(
+            "Removed", "remove:")
+
         fs_delete(base, remove=0)
-        assert sys.stdout.buffer == exp, sys.stdout.buffer
+        assert sys.stdout.buffer == exp_noop, sys.stdout.buffer
         assert os.path.exists(sub1_yyy)
 
         sys.stdout.buffer = ""


--- orig/test/CacheDir.py
+++ mod/test/CacheDir.py
@@ -69,12 +69,9 @@
 # Verify that building with -n and an empty cache reports that proper
 # build operations would be taken, but that nothing is actually built
 # and that the cache is still empty.
-test.run(chdir = 'src', arguments = '-n .', stdout = test.wrap_stdout("""\
-cat(["aaa.out"], ["aaa.in"])
-cat(["bbb.out"], ["bbb.in"])
-cat(["ccc.out"], ["ccc.in"])
-cat(["all"], ["aaa.out", "bbb.out", "ccc.out"])
-"""))
+test.run(chdir = 'src', arguments = '-n .',
+         stdout = test.wrap_stdout(noexec=['aaa.out', 'bbb.out',
+                                           'ccc.out', 'all']))
 
 test.must_not_exist(test.workpath('src', 'aaa.out'))
 test.must_not_exist(test.workpath('src', 'bbb.out'))
@@ -112,11 +109,11 @@
 # Verify that rebuilding with -n reports that everything was retrieved
 # from the cache, but that nothing really was.
 test.run(chdir = 'src', arguments = '-n .', stdout = test.wrap_stdout("""\
-Retrieved `aaa.out' from cache
-Retrieved `bbb.out' from cache
-Retrieved `ccc.out' from cache
-Retrieved `all' from cache
-"""))
+build: aaa.out (cached)
+build: bbb.out (cached)
+build: ccc.out (cached)
+build: all (cached)
+""", noexec=1))
 
 test.must_not_exist(test.workpath('src', 'aaa.out'))
 test.must_not_exist(test.workpath('src', 'bbb.out'))
@@ -205,11 +202,12 @@
 # Verify that rebuilding with -n reports that everything was retrieved
 # from the cache, but that nothing really was.
 test.run(arguments = '-n .', stdout = test.wrap_stdout("""\
-Retrieved `%s' from cache
-Retrieved `%s' from cache
-Retrieved `%s' from cache
-Retrieved `%s' from cache
-""" % (build_aaa_out, build_bbb_out, build_ccc_out, build_all)))
+build: %s (cached)
+build: %s (cached)
+build: %s (cached)
+build: %s (cached)
+""" % (build_aaa_out, build_bbb_out, build_ccc_out, build_all),
+noexec=1))
 
 test.must_not_exist(test.workpath('build', 'aaa.out'))
 test.must_not_exist(test.workpath('build', 'bbb.out'))


--- orig/test/Chmod.py
+++ mod/test/Chmod.py
@@ -82,17 +82,7 @@
 os.chmod(test.workpath('Chmod-f7.in'), 0444)
 os.chmod(test.workpath('f7.out-Chmod'), 0444)
 
-expect = test.wrap_stdout(read_str = 'Chmod("f1", 0666)\nChmod("d2", 0777)\n',
-                          build_str = """\
-cat(["bar.out"], ["bar.in"])
-Chmod("f3", 0666)
-Chmod("d4", 0777)
-Chmod("f5", 0666)
-cat(["f6.out"], ["f6.in"])
-cat(["f7.out"], ["f7.in"])
-Chmod("Chmod-f7.in", 0666)
-Chmod("f7.out-Chmod", 0666)
-""")
+expect = test.wrap_stdout(noexec=['bar.out', 'f6.out', 'f7.out'])
 test.run(options = '-n', arguments = '.', stdout = expect)
 
 s = stat.S_IMODE(os.stat(test.workpath('f1'))[stat.ST_MODE])


--- orig/test/Configure.py
+++ mod/test/Configure.py
@@ -92,7 +92,7 @@
 
 def checkLogAndStdout(checks, results, cached,
                       test, logfile, sconf_dir, sconstruct,
-                      doCheckLog=1, doCheckStdout=1):
+                      doCheckLog=1, doCheckStdout=1, dryrun=0):
     class NoMatch:
         def __init__(self, p):
             self.pos = p
@@ -190,7 +190,7 @@
         test.fail_test()
 
     if doCheckStdout:
-        exp_stdout = test.wrap_stdout(".*", rdstr)
+        exp_stdout = test.wrap_stdout(".*", rdstr, noexec=dryrun, re_match=1)
         if not test.match_re_dotall(test.stdout(), exp_stdout):
             print "Unexpected stdout: "
             print "-----------------------------------------------------"
@@ -662,7 +662,7 @@
                         [[((".c", CR), (_obj, CR))],
                          [((".c", CR), (_obj, CF))]],
                         test, "config.log", ".sconf_temp", "SConstruct",
-                        doCheckLog=0)
+                        doCheckLog=0, dryrun=1)
     newLog = test.read(test.workpath(work_dir, 'config.log'))
     if newLog != oldLog:
         print "Unexpected update of log file within a dry run"


--- orig/test/Copy.py
+++ mod/test/Copy.py
@@ -71,21 +71,7 @@
 test.write('f8.in', "f8.in\n")
 test.write('f9.in', "f9.in\n")
 
-expect = test.wrap_stdout(read_str = """\
-Copy("f1.out", "f1.in")
-Copy("d2.out", "d2.in")
-Copy("d3.out", "f3.in")
-""",
-                          build_str = """\
-cat(["bar.out"], ["bar.in"])
-Copy("f4.out", "f4.in")
-Copy("d5.out", "d5.in")
-Copy("d6.out", "f6.in")
-Copy("f7.out", "f7.in")
-cat(["f8.out"], ["f8.in"])
-cat(["f9.out"], ["f9.in"])
-Copy("f9.out-Copy", "f9.in")
-""")
+expect = test.wrap_stdout(noexec=['bar.out', 'f8.out', 'f9.out'])
 test.run(options = '-n', arguments = '.', stdout = expect)
 
 test.must_not_exist('f1.out')


--- orig/test/Delete.py
+++ mod/test/Delete.py
@@ -82,29 +82,11 @@
 test.write('f12.in', "f12.in\n")
 test.subdir('d13.in')
 
-expect = test.wrap_stdout(read_str = """\
-Delete("f1")
-Delete("d2")
-""",
-                          build_str = """\
-Delete("d11-nonexistent.out")
-Mkdir("d11-nonexistent.out")
-Delete("d13-nonexistent.out")
-Mkdir("d13-nonexistent.out")
-Delete("f10-nonexistent.out")
-cat(["f10-nonexistent.out"], ["f10.in"])
-Delete("f12-nonexistent.out")
-cat(["f12-nonexistent.out"], ["f12.in"])
-cat(["f3.out"], ["f3.in"])
-Delete("f4")
-Delete("d5")
-Delete("f6")
-Delete("d7")
-cat(["f8.out"], ["f8.in"])
-cat(["f9.out"], ["f9.in"])
-Delete("Delete-f9.in")
-Delete("f9.out-Delete")
-""")
+expect = test.wrap_stdout(noexec=['d11-nonexistent.out',
+                                  'd13-nonexistent.out',
+                                  'f10-nonexistent.out',
+                                  'f12-nonexistent.out',
+                                  'f3.out', 'f8.out', 'f9.out'])
 test.run(options = '-n', arguments = '.', stdout = expect)
 
 test.must_exist('f1')


--- orig/test/Mkdir.py
+++ mod/test/Mkdir.py
@@ -57,16 +57,7 @@
 test.write('f5.in', "f5.in\n")
 test.write('f6.in', "f6.in\n")
 
-expect = test.wrap_stdout(read_str = 'Mkdir("d1")\n',
-                          build_str = """\
-cat(["f2.out"], ["f2.in"])
-Mkdir("d3")
-Mkdir("d4")
-cat(["f5.out"], ["f5.in"])
-cat(["f6.out"], ["f6.in"])
-Mkdir("Mkdir-f6.in")
-Mkdir("f6.out-Mkdir")
-""")
+expect = test.wrap_stdout(noexec=['f2.out', 'f5.out', 'f6.out'])
 test.run(options = '-n', arguments = '.', stdout = expect)
 
 test.must_not_exist('d1')


--- orig/test/Move.py
+++ mod/test/Move.py
@@ -57,15 +57,7 @@
 test.write('f6.in', "f6.in\n")
 test.write('f6.in-Move', "f6.in-Move\n")
 
-expect = test.wrap_stdout(read_str = 'Move("f1.out", "f1.in")\n',
-                          build_str = """\
-cat(["f2.out"], ["f2.in"])
-Move("f3.out", "f3.in")
-Move("f4.out", "f4.in")
-cat(["f5.out"], ["f5.in"])
-cat(["f6.out"], ["f6.in"])
-Move("Move-f6.out", "f6.in-Move")
-""")
+expect = test.wrap_stdout(noexec=['f2.out', 'f5.out','f6.out'])
 test.run(options = '-n', arguments = '.', stdout = expect)
 
 test.must_not_exist('f1.out')


--- orig/test/QT.py
+++ mod/test/QT.py
@@ -198,15 +198,15 @@
 """)
 
 test.run(chdir='work1', arguments = aaa_exe)
-test.up_to_date(chdir='work1', options = '-n', arguments=aaa_exe)
+test.up_to_date(chdir='work1', noexec=1, arguments=aaa_exe)
 
-test.up_to_date(chdir='work1', options = '-n', arguments = aaa_exe)
+test.up_to_date(chdir='work1', noexec=1, arguments = aaa_exe)
 test.write(['work1', 'aaa.h'], r"""
 /* a change */
 #include "my_qobject.h"
 void aaa(void) Q_OBJECT;
 """)
-test.not_up_to_date(chdir='work1', options='-n', arguments = moc)
+test.not_up_to_date(chdir='work1', noexec=1, arguments = moc)
 test.run(program = test.workpath('work1', aaa_exe), stdout = 'aaa.h\n')
 
 test.run(chdir='work1',
@@ -257,7 +257,7 @@
 """)
 
 test.run(chdir='work2', arguments = aaa_dll)
-test.up_to_date(chdir='work2', options='-n',arguments = aaa_dll)
+test.up_to_date(chdir='work2', noexec=1, arguments = aaa_dll)
 test.write(['work2', 'aaa.ui'], r"""
 /* a change */
 #if defined (_WIN32) || defined(__CYGWIN__)
@@ -267,9 +267,9 @@
 #endif
 DLLEXPORT void aaa(void)
 """)
-test.not_up_to_date(chdir='work2', options = '-n', arguments = moc)
-test.not_up_to_date(chdir='work2', options = '-n', arguments = cpp)
-test.not_up_to_date(chdir='work2', options = '-n', arguments = h)
+test.not_up_to_date(chdir='work2', noexec = 1, arguments = moc)
+test.not_up_to_date(chdir='work2', noexec = 1, arguments = cpp)
+test.not_up_to_date(chdir='work2', noexec = 1, arguments = h)
 test.run(chdir='work2', arguments = aaa_dll)
 test.write(['work2', 'aaa.ui.h'], r"""
 /* test dependency to .ui.h */
@@ -282,10 +282,10 @@
 test.write(['work2', 'aaa.ui.h'], r"""
 /* changed */
 """)
-test.not_up_to_date(chdir='work2', options = '-n', arguments = obj)
-test.up_to_date(chdir='work2', options = '-n', arguments = cpp)
-test.up_to_date(chdir='work2', options = '-n', arguments = h)
-test.up_to_date(chdir='work2', options = '-n', arguments = moc)
+test.not_up_to_date(chdir='work2', noexec = 1, arguments = obj)
+test.up_to_date(chdir='work2', noexec = 1, arguments = cpp)
+test.up_to_date(chdir='work2', noexec = 1, arguments = h)
+test.up_to_date(chdir='work2', noexec = 1, arguments = moc)
 # clean up
 test.run(chdir='work2', arguments = '-c ' + aaa_dll)
 
@@ -353,14 +353,14 @@
 test.run(chdir='work3', arguments = lib_aaa,
          stderr=TestSCons.noisy_ar,
          match=TestSCons.match_re_dotall)
-test.up_to_date(chdir='work3', options = '-n', arguments = lib_aaa)
+test.up_to_date(chdir='work3', noexec = 1, arguments = lib_aaa)
 test.write(['work3', 'aaa.cpp'], r"""
 #include "my_qobject.h"
 /* a change */
 void aaa(void) Q_OBJECT
 #include "%s"
 """ % moc)
-test.not_up_to_date(chdir='work3', options = '-n', arguments = moc)
+test.not_up_to_date(chdir='work3', noexec = 1, arguments = moc)
 test.run(chdir='work3', options = '-c', arguments = lib_aaa)
 
 test.run(chdir='work3',


--- orig/test/Repository/option-n.py
+++ mod/test/Repository/option-n.py
@@ -76,10 +76,15 @@
 scons: `aaa.out' is up to date.
 """ % repository_aaa_out)
 
+noexec_expect = test.wrap_stdout("""\
+build: aaa.out
+scons: `aaa.out' is up to date.
+""", noexec=1)
+
 test.run(chdir = 'work',
          options = opts,
          arguments = '-n aaa.out',
-         stdout = expect)
+         stdout = noexec_expect)
 
 test.fail_test(os.path.exists(work_aaa_out))
 


--- orig/test/TARGETS.py
+++ mod/test/TARGETS.py
@@ -59,7 +59,7 @@
                           build_str = """\
 scons: Nothing to be done for `bbb'.
 scons: Nothing to be done for `aaa'.
-""")
+""", noexec=1)
 test.run(arguments = 'bbb ccc=xyz -n aaa', stdout = expect)
 
 test.write('SConstruct', """


--- orig/test/Touch.py
+++ mod/test/Touch.py
@@ -60,16 +60,7 @@
 
 oldtime = os.path.getmtime(test.workpath('f1'))
 
-expect = test.wrap_stdout(read_str = 'Touch("f1")\n',
-                          build_str = """\
-cat(["f2.out"], ["f2.in"])
-Touch("f3")
-Touch("f4")
-cat(["f5.out"], ["f5.in"])
-cat(["f6.out"], ["f6.in"])
-Touch("Touch-f6.in")
-Touch("f6.out-Touch")
-""")
+expect = test.wrap_stdout(noexec=['f2.out', 'f5.out', 'f6.out'])
 test.run(options = '-n', arguments = '.', stdout = expect)
 
 test.sleep(2)


--- orig/test/chdir.py
+++ mod/test/chdir.py
@@ -255,7 +255,8 @@
 os.chdir('%(work2)s')
 """ % locals())
 
-test.run(chdir='work2', arguments='-n .', stdout=expect)
+test.run(chdir='work2', arguments='-n .',
+         stdout=test.wrap_stdout(noexec=['sub/f1.out', 'sub/f2.out']))
 
 test.must_not_exist(work2_sub_f1_out)
 test.must_not_exist(work2_sub_f2_out)


--- orig/test/option--cs.py
+++ mod/test/option--cs.py
@@ -123,12 +123,8 @@
 # clean up.
 test.run(chdir = 'src1',
          arguments = '--cache-show -n .',
-         stdout = test.wrap_stdout("""\
-%s build.py aaa.out aaa.in
-%s build.py bbb.out bbb.in
-cat(["ccc.out"], ["ccc.in"])
-cat(["all"], ["aaa.out", "bbb.out", "ccc.out"])
-""" % (python, python)))
+         stdout = test.wrap_stdout(noexec=['aaa.out', 'bbb.out',
+                                           'ccc.out', 'all']))
 
 test.must_not_exist(test.workpath('src1', 'cat.out'))
 


--- orig/test/option-c.py
+++ mod/test/option-c.py
@@ -128,11 +128,9 @@
 
 test.run(arguments = 'foo1.out foo2.out foo3.out')
 
-expect = test.wrap_stdout("""Removed foo1.out
-Removed foo2.xxx
-Removed foo2.out
-Removed foo3.out
-""", cleaning=1)
+expect = test.wrap_stdout(cleaning=1,
+                          noexec=['foo1.out', 'foo2.xxx',
+                                  'foo2.out', 'foo3.out'])
 
 test.run(arguments = '-c -n foo1.out foo2.out foo3.out', stdout = expect)
 
@@ -188,15 +186,15 @@
 test.run(arguments = '-c subd', stdout=expect)
 test.fail_test(os.path.exists(test.workpath('foox.in')))
 
-expect = test.wrap_stdout("""Removed foo1.out
-Removed foo2.xxx
-Removed foo2.out
-Removed foo3.out
-Removed %s
-Removed %s
-Removed directory subd
+expect = test.wrap_stdout("""remove: foo1.out
+remove: foo2.xxx
+remove: foo2.out
+remove: foo3.out
+remove: %s
+remove: %s
+remove dir: subd
 """ % (os.path.join('subd','SConscript'), os.path.join('subd', 'foon.in')),
-                          cleaning = 1)
+                          cleaning = 1, noexec = 1)
 test.run(arguments = '-c -n .', stdout=expect)
 
 expect = test.wrap_stdout("""Removed foo1.out


--- orig/test/option-n.py
+++ mod/test/option-n.py
@@ -25,7 +25,7 @@
 """
 This test verifies:
     1)  that we don't build files when we use the -n, --no-exec,
-        --just-print, --dry-run, and --recon options;
+        --dry-run, and --recon options;
     2)  that we don't remove built files when -n is used in
         conjunction with -c;
     3)  that files installed by the Install() method don't get
@@ -81,73 +81,71 @@
 test.write(['src', 'f4.in'], "src/f4.in\n")
 
 args = 'f1.out f2.out'
+
 expect = test.wrap_stdout("""\
 %s build.py f1.out
 %s build.py f2.out
 """ % (python, python))
 
+noexec_expect = test.wrap_stdout(noexec=['f1.out', 'f2.out'])
+
 test.run(arguments = args, stdout = expect)
-test.fail_test(not os.path.exists(test.workpath('f1.out')))
-test.fail_test(not os.path.exists(test.workpath('f2.out')))
+test.must_exist('f1.out')
+test.must_exist('f2.out')
 
 test.unlink('f1.out')
 test.unlink('f2.out')
 
-test.run(arguments = '-n ' + args, stdout = expect)
-test.fail_test(os.path.exists(test.workpath('f1.out')))
-test.fail_test(os.path.exists(test.workpath('f2.out')))
-
-test.run(arguments = '--no-exec ' + args, stdout = expect)
-test.fail_test(os.path.exists(test.workpath('f1.out')))
-test.fail_test(os.path.exists(test.workpath('f2.out')))
-
-test.run(arguments = '--just-print ' + args, stdout = expect)
-test.fail_test(os.path.exists(test.workpath('f1.out')))
-test.fail_test(os.path.exists(test.workpath('f2.out')))
-
-test.run(arguments = '--dry-run ' + args, stdout = expect)
-test.fail_test(os.path.exists(test.workpath('f1.out')))
-test.fail_test(os.path.exists(test.workpath('f2.out')))
-
-test.run(arguments = '--recon ' + args, stdout = expect)
-test.fail_test(os.path.exists(test.workpath('f1.out')))
-test.fail_test(os.path.exists(test.workpath('f2.out')))
+test.run(arguments = '-n ' + args, stdout = noexec_expect)
+test.must_not_exist('f1.out')
+test.must_not_exist('f2.out')
+
+test.run(arguments = '--no-exec ' + args, stdout = noexec_expect)
+test.must_not_exist('f1.out')
+test.must_not_exist('f2.out')
+
+test.run(arguments = '--dry-run ' + args, stdout = noexec_expect)
+test.must_not_exist('f1.out')
+test.must_not_exist('f2.out')
+
+test.run(arguments = '--recon ' + args, stdout = noexec_expect)
+test.must_not_exist('f1.out')
+test.must_not_exist('f2.out')
 
 test.run(arguments = args)
-test.fail_test(not os.path.exists(test.workpath('f1.out')))
+test.must_exist('f1.out')
 
 # Test that SCons does not write a modified .sconsign when -n is used.
-expect = test.wrap_stdout("""\
-%s build.py f1.out
-""" % python)
+expect = test.wrap_stdout(noexec = ['f1.out'])
 test.unlink('.sconsign')
 test.write('f1.out', "X1.out\n")
 test.run(arguments = '-n f1.out', stdout = expect)
 test.run(arguments = '-n f1.out', stdout = expect)
 
-expect = test.wrap_stdout("Removed f1.out\nRemoved f2.out\n", cleaning=1)
+expect = test.wrap_stdout(cleaning=1, noexec=['f1.out', 'f2.out'])
 
 test.run(arguments = '-n -c ' + args, stdout = expect)
 
 test.run(arguments = '-c -n ' + args, stdout = expect)
 
-test.fail_test(not os.path.exists(test.workpath('f1.out')))
-test.fail_test(not os.path.exists(test.workpath('f2.out')))
+test.must_exist('f1.out')
+test.must_exist('f2.out')
 
 #
 install_f3_in = os.path.join('install', 'f3.in')
 expect = test.wrap_stdout('Install file: "f3.in" as "%s"\n' % install_f3_in)
+noexec_expect = test.wrap_stdout(noexec=[install_f3_in])
 
-test.run(arguments = '-n install', stdout = expect)
-test.fail_test(os.path.exists(test.workpath('install', 'f3.in')))
+test.run(arguments = '-n install', stdout = noexec_expect)
+test.must_not_exist(['install', 'f3.in'])
 
 test.run(arguments = 'install', stdout = expect)
-test.fail_test(not os.path.exists(test.workpath('install', 'f3.in')))
+test.must_exist(['install', 'f3.in'])
 
 test.write('f3.in', "f3.in again\n")
 
-test.run(arguments = '-n install', stdout = expect)
-test.fail_test(not os.path.exists(test.workpath('install', 'f3.in')))
+test.run(arguments = '-n install', stdout = noexec_expect)
+test.must_exist(['install', 'f3.in'])
 
 # Make sure duplicate source files in a BuildDir aren't created
 # when the -n option is used.
@@ -166,7 +164,7 @@
     test.unlink(test.workpath('build', 'f4.in'))
 
 test.run(arguments = '-n build')
-test.fail_test(os.path.exists(test.workpath('build', 'f4.in')))
+test.must_not_exist(['build', 'f4.in'])
 
 # test Configure-calls in conjunction with -n
 test.subdir('configure')
@@ -201,8 +199,8 @@
 """
 test.run(arguments="-n",stderr=stderr,status=2,
          chdir=test.workpath("configure"))
-test.fail_test(os.path.exists(test.workpath("configure", "config.test")))
-test.fail_test(os.path.exists(test.workpath("configure", "config.log")))
+test.must_not_exist(["configure", "config.test"])
+test.must_not_exist(["configure", "config.log"])
 
 # test that targets are not built, if conf_dir exists.
 # verify that .cache and config.log are not created.
@@ -214,22 +212,24 @@
 test.subdir(['configure','config.test'])
 test.run(arguments="-n",stderr=stderr,status=2,
          chdir=test.workpath("configure"))
-test.fail_test(os.path.exists(test.workpath("configure", "config.test",
-                                            ".cache")))
-test.fail_test(os.path.exists(test.workpath("configure", "config.test",
-                                            "conftest_0")))
-test.fail_test(os.path.exists(test.workpath("configure", "config.test",
-                                            "conftest_0.in")))
-test.fail_test(os.path.exists(test.workpath("configure", "config.log")))
+test.must_not_exist(["configure", "config.test", ".cache"])
+test.must_not_exist(["configure", "config.test", "conftest_0"])
+test.must_not_exist(["configure", "config.test", "conftest_0.in"])
+test.must_not_exist(["configure", "config.log"])
 
 # test that no error is raised, if all targets are up-to-date. In this
 # case .cache and config.log shouldn't be created
 stdout=test.wrap_stdout(build_str="scons: `.' is up to date.\n",
                         read_str=r"""Executing Custom Test ... \(cached\) yes
 """)
+noexec=string.replace(string.replace(
+    test.wrap_stdout(build_str="scons: `.' is up to date.\n",
+                     read_str="Executing Custom Test ... (cached) yes\n",
+                     noexec=1),
+                     '(', '\('), ')', '\)')
 test.run(status=0,chdir=test.workpath("configure"))
 log1_mtime = os.path.getmtime(test.workpath("configure","config.log"))
-test.run(stdout=stdout,arguments="-n",status=0,
+test.run(stdout=noexec,arguments="-n",status=0,
          chdir=test.workpath("configure"))
 log2_mtime = os.path.getmtime(test.workpath("configure","config.log"))
 test.fail_test( log1_mtime != log2_mtime )



