Index: src/engine/SCons/Node/Python.py
===================================================================
RCS file: /cvsroot/scons/scons/src/engine/SCons/Node/Python.py,v
retrieving revision 1.7
diff -u -r1.7 Python.py
--- src/engine/SCons/Node/Python.py	7 Jun 2005 11:34:22 -0000	1.7
+++ src/engine/SCons/Node/Python.py	21 Sep 2005 00:28:12 -0000
@@ -31,6 +31,51 @@
 
 import SCons.Node
 
+def makeStringForSequence(bkts, value, buf=None):
+    if buf is None:
+        from cStringIO import StringIO
+        buf = StringIO()
+    buf.write(bkts[0])
+    first = True
+    for x in value:
+        if first: first = False
+        else: buf.write(', ')
+        buf.write(makeString(x))
+    buf.write(bkts[1])
+    return buf.getvalue()
+
+def makeStringForDict(value, buf=None):
+    if buf is None:
+        from cStringIO import StringIO
+        buf = StringIO()
+    buf.write('{')
+    first = True
+    for k, v in value.iteritems():
+        if first: first = False
+        else: buf.write(', ')
+        buf.write(makeString(k, buf))
+        buf.write(':')
+        buf.write(makeString(v, buf))
+    buf.write('}')
+    return buf.getvalue()
+    
+def makeString(value, buf=None):
+    if isinstance(value, SCons.Node.Node):
+        if buf is None: return repr(str(value))
+        else:
+            buf.write(repr(str(value)))
+            return buf.getvalue()
+    if isinstance(value, list):
+        return makeStringForSequence('[]', value, buf)
+    if isinstance(value, tuple):
+        return makeStringForSequence('()', value, buf)
+    if isinstance(value, dict):
+        return makeStringForDict(value, buf)
+    if buf is None: return repr(value)
+    else:
+        buf.write(repr(value))
+        return buf.getvalue()
+        
 class Value(SCons.Node.Node):
     """A class for Python variables, typically passed on the command line 
     or generated by a script, but not from a file or some other source.
@@ -40,7 +85,7 @@
         self.value = value
 
     def __str__(self):
-        return repr(self.value)
+        return '##V'+makeString(self.value)
 
     def build(self):
         """A "builder" for Values."""
@@ -57,7 +102,7 @@
     def get_contents(self):
         """The contents of a Value are the concatenation
         of all the contents of its sources with the node's value itself."""
-        contents = str(self.value)
+        contents = self.__str__()
         for kid in self.children(None):
             contents = contents + kid.get_contents()
         return contents
Index: src/engine/SCons/Node/__init__.py
===================================================================
RCS file: /cvsroot/scons/scons/src/engine/SCons/Node/__init__.py,v
retrieving revision 1.180
diff -u -r1.180 __init__.py
--- src/engine/SCons/Node/__init__.py	7 Jun 2005 11:34:22 -0000	1.180
+++ src/engine/SCons/Node/__init__.py	21 Sep 2005 00:28:05 -0000
@@ -516,11 +516,19 @@
             implicit = self.get_stored_implicit()
             if implicit:
                 factory = build_env.get_factory(self.builder.source_factory)
-                implicit = map(factory, implicit)
-                self._add_child(self.implicit, self.implicit_dict, implicit)
-                calc = build_env.get_calculator()
-                if implicit_deps_unchanged or self.current(calc):
-                    return
+                try:
+                    implicit = map(factory, implicit)
+                    self._add_child(self.implicit, self.implicit_dict, implicit)
+                    calc = build_env.get_calculator()
+                    if implicit_deps_unchanged or self.current(calc):
+                        return
+                except TypeError:
+                    # This happens if the source_factory changed - we get an
+                    # exception because the *old* dependency is the wrong
+                    # type (Dir vs. File).  This is a clear indication that
+                    # the dependencies have changed, don't you think?
+                    pass 
+                    
                 # one of this node's sources has changed, so
                 # we need to recalculate the implicit deps,
                 # and the bsig:
@@ -984,8 +1014,15 @@
         # so we only print them after running them through this lambda
         # to turn them into the right relative Node and then return
         # its string.
-        stringify = lambda s, E=self.dir.Entry: str(E(s))
-
+        #stringify = lambda s, E=self.dir.Entry: (isinstance(s, Node) and str(s)) or str(E(s))
+        #stringify = lambda s, E=self.dir.Entry: str(E(s))
+        def stringify(x):
+            if not isinstance(x, Node):
+                if x.startswith('##V'):
+                    return x
+                x = self.dir.Entry(x)
+            return str(x)
+        
         lines = []
 
         removed = filter(lambda x, nk=new_bkids: not x in nk, old_bkids)
