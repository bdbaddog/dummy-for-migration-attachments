Index: test/DVIPS/DVIPSFLAGS.py
===================================================================
--- test/DVIPS/DVIPSFLAGS.py	(revision 2970)
+++ test/DVIPS/DVIPSFLAGS.py	(working copy)
@@ -39,8 +39,10 @@
 test.write('mytex.py', r"""
 import os
 import sys
-base_name = os.path.splitext(sys.argv[1])[0]
-infile = open(sys.argv[1], 'rb')
+import getopt
+cmd_opts, arg = getopt.getopt(sys.argv[1:], 'i:', [])
+base_name = os.path.splitext(arg[0])[0]
+infile = open(arg[0], 'rb')
 out_file = open(base_name+'.dvi', 'wb')
 for l in infile.readlines():
     if l[:4] != '#tex':
@@ -51,8 +53,10 @@
 test.write('mylatex.py', r"""
 import os
 import sys
-base_name = os.path.splitext(sys.argv[1])[0]
-infile = open(sys.argv[1], 'rb')
+import getopt
+cmd_opts, arg = getopt.getopt(sys.argv[1:], 'i:', [])
+base_name = os.path.splitext(arg[0])[0]
+infile = open(arg[0], 'rb')
 out_file = open(base_name+'.dvi', 'wb')
 for l in infile.readlines():
     if l[:6] != '#latex':
Index: test/DVIPS/DVIPS.py
===================================================================
--- test/DVIPS/DVIPS.py	(revision 2970)
+++ test/DVIPS/DVIPS.py	(working copy)
@@ -39,8 +39,10 @@
 test.write('mytex.py', r"""
 import os
 import sys
-base_name = os.path.splitext(sys.argv[1])[0]
-infile = open(sys.argv[1], 'rb')
+import getopt
+cmd_opts, arg = getopt.getopt(sys.argv[1:], 'i:', [])
+base_name = os.path.splitext(arg[0])[0]
+infile = open(arg[0], 'rb')
 out_file = open(base_name+'.dvi', 'wb')
 for l in infile.readlines():
     if l[:4] != '#tex':
@@ -51,8 +53,10 @@
 test.write('mylatex.py', r"""
 import os
 import sys
-base_name = os.path.splitext(sys.argv[1])[0]
-infile = open(sys.argv[1], 'rb')
+import getopt
+cmd_opts, arg = getopt.getopt(sys.argv[1:], 'i:', [])
+base_name = os.path.splitext(arg[0])[0]
+infile = open(arg[0], 'rb')
 out_file = open(base_name+'.dvi', 'wb')
 for l in infile.readlines():
     if l[:6] != '#latex':
Index: test/DVIPDF/DVIPDFFLAGS.py
===================================================================
--- test/DVIPDF/DVIPDFFLAGS.py	(revision 2970)
+++ test/DVIPDF/DVIPDFFLAGS.py	(working copy)
@@ -39,8 +39,10 @@
 test.write('mytex.py', r"""
 import os
 import sys
-base_name = os.path.splitext(sys.argv[1])[0]
-infile = open(sys.argv[1], 'rb')
+import getopt
+cmd_opts, arg = getopt.getopt(sys.argv[1:], 'i:', [])
+base_name = os.path.splitext(arg[0])[0]
+infile = open(arg[0], 'rb')
 out_file = open(base_name+'.dvi', 'wb')
 for l in infile.readlines():
     if l[:4] != '#tex':
@@ -51,8 +53,10 @@
 test.write('mylatex.py', r"""
 import os
 import sys
-base_name = os.path.splitext(sys.argv[1])[0]
-infile = open(sys.argv[1], 'rb')
+import getopt
+cmd_opts, arg = getopt.getopt(sys.argv[1:], 'i:', [])
+base_name = os.path.splitext(arg[0])[0]
+infile = open(arg[0], 'rb')
 out_file = open(base_name+'.dvi', 'wb')
 for l in infile.readlines():
     if l[:6] != '#latex':
Index: test/DVIPDF/DVIPDF.py
===================================================================
--- test/DVIPDF/DVIPDF.py	(revision 2970)
+++ test/DVIPDF/DVIPDF.py	(working copy)
@@ -39,8 +39,10 @@
 test.write('mytex.py', r"""
 import os
 import sys
-base_name = os.path.splitext(sys.argv[1])[0]
-infile = open(sys.argv[1], 'rb')
+import getopt
+cmd_opts, arg = getopt.getopt(sys.argv[1:], 'i:', [])
+base_name = os.path.splitext(arg[0])[0]
+infile = open(arg[0], 'rb')
 out_file = open(base_name+'.dvi', 'wb')
 for l in infile.readlines():
     if l[:4] != '#tex':
@@ -51,8 +53,10 @@
 test.write('mylatex.py', r"""
 import os
 import sys
-base_name = os.path.splitext(sys.argv[1])[0]
-infile = open(sys.argv[1], 'rb')
+import getopt
+cmd_opts, arg = getopt.getopt(sys.argv[1:], 'i:', [])
+base_name = os.path.splitext(arg[0])[0]
+infile = open(arg[0], 'rb')
 out_file = open(base_name+'.dvi', 'wb')
 for l in infile.readlines():
     if l[:6] != '#latex':
@@ -63,8 +67,10 @@
 test.write('mydvipdf.py', r"""
 import os
 import sys
-infile = open(sys.argv[1], 'rb')
-out_file = open(sys.argv[2], 'wb')
+import getopt
+cmd_opts, arg = getopt.getopt(sys.argv[1:], 'i:', [])
+infile = open(arg[0], 'rb')
+out_file = open(arg[1], 'wb')
 for l in infile.readlines():
     if l[:7] != '#dvipdf':
         out_file.write(l)
Index: test/TEX/variant_dir_dup0.py
===================================================================
--- test/TEX/variant_dir_dup0.py	(revision 2970)
+++ test/TEX/variant_dir_dup0.py	(working copy)
@@ -62,7 +62,9 @@
 Import('env')
 
 test_dvi = env.DVI(source='test.tex')
-testpdf = env.PDF(source=test_dvi)
+test2_dvi = env.DVI(target='result',source='test2.tex')
+testpdf = env.PDF(target='pdfoutput',source=test_dvi)
+test2pdf = env.PDF(target='pdfoutput.xyz',source=test2_dvi)
 """)
 
 
@@ -228,7 +230,64 @@
 \end{document}
 """)
 
+test.write(['docs', 'test2.tex'],
+r"""\documentclass{report}
 
+\usepackage{graphicx}
+\usepackage{epsfig,color} % for .tex version of figures if we go that way
+
+\usepackage{makeidx}
+\makeindex
+
+\begin{document}
+ 
+\title{Report Title}
+
+\author{A. N. Author}
+ 
+\maketitle 
+ 
+\begin{abstract}
+there is no abstract
+\end{abstract}
+
+\tableofcontents
+\listoffigures
+
+\chapter{Introduction}
+
+The introduction is short.
+
+\index{Acknowledgements}
+
+\section{Acknowledgements}
+
+The Acknowledgements are show as well \cite{AnAuthor:2006fk}.  
+
+\index{Getting the Report}
+
+To get a hard copy of this report call me.
+
+\begin{figure}[htbp]
+\begin{center}
+\input{Fig1.tex} % testing figure variant that uses TeX labeling
+\caption{Zone and Node indexing}
+\label{fig1}
+\end{center}
+\end{figure}
+
+All done now.
+
+\bibliographystyle{unsrt}
+\bibliography{test}
+\newpage
+
+\printindex
+
+\end{document}
+""")
+
+
 # makeindex will write status messages to stderr (grrr...), so ignore it.
 test.run(arguments = '.', stderr=None)
 
@@ -245,8 +304,19 @@
     'test.ind',
     'test.lof',
     'test.log',
-    'test.pdf',
     'test.toc',
+    'test2.aux',
+    'test2.bbl',
+    'test2.blg',
+    'test2.idx',
+    'test2.ilg',
+    'test2.ind',
+    'test2.lof',
+    'test2.log',
+    'test2.toc',
+    'result.dvi',
+    'pdfoutput.pdf',
+    'pdfoutput.xyz'
 ]
 
 for f in files:
Index: test/TEX/TEX.py
===================================================================
--- test/TEX/TEX.py	(revision 2970)
+++ test/TEX/TEX.py	(working copy)
@@ -45,8 +45,10 @@
 test.write('mytex.py', r"""
 import sys
 import os
-base_name = os.path.splitext(sys.argv[1])[0]
-infile = open(sys.argv[1], 'rb')
+import getopt
+cmd_opts, arg = getopt.getopt(sys.argv[1:], 'i:', [])
+base_name = os.path.splitext(arg[0])[0]
+infile = open(arg[0], 'rb')
 dvi_file = open(base_name+'.dvi', 'wb')
 aux_file = open(base_name+'.aux', 'wb')
 log_file = open(base_name+'.log', 'wb')
@@ -175,7 +177,8 @@
     test.run(stderr = None)
     output_lines = string.split(test.stdout(), '\n')
 
-    reruns = filter(lambda x: string.find(x, 'latex rerun.tex') != -1, output_lines)
+    reruns = filter(lambda x: string.find(x, 'latex -interaction=nonstopmode rerun.tex') != -1, output_lines)
+
     if len(reruns) != 2:
         print "Expected 2 latex calls, got %s:" % len(reruns)
         print string.join(reruns, '\n')
Index: test/TEX/PDFLATEX.py
===================================================================
--- test/TEX/PDFLATEX.py	(revision 2970)
+++ test/TEX/PDFLATEX.py	(working copy)
@@ -45,8 +45,10 @@
 test.write('mypdflatex.py', r"""
 import sys
 import os
-base_name = os.path.splitext(sys.argv[1])[0]
-infile = open(sys.argv[1], 'rb')
+import getopt
+cmd_opts, arg = getopt.getopt(sys.argv[1:], 'i:', [])
+base_name = os.path.splitext(arg[0])[0]
+infile = open(arg[0], 'rb')
 pdf_file = open(base_name+'.pdf', 'wb')
 aux_file = open(base_name+'.aux', 'wb')
 log_file = open(base_name+'.log', 'wb')
Index: test/TEX/LATEX.py
===================================================================
--- test/TEX/LATEX.py	(revision 2970)
+++ test/TEX/LATEX.py	(working copy)
@@ -45,8 +45,10 @@
 test.write('mylatex.py', r"""
 import sys
 import os
-base_name = os.path.splitext(sys.argv[1])[0]
-infile = open(sys.argv[1], 'rb')
+import getopt
+cmd_opts, arg = getopt.getopt(sys.argv[1:], 'i:', [])
+base_name = os.path.splitext(arg[0])[0]
+infile = open(arg[0], 'rb')
 dvi_file = open(base_name+'.dvi', 'wb')
 aux_file = open(base_name+'.aux', 'wb')
 log_file = open(base_name+'.log', 'wb')
@@ -112,9 +114,10 @@
 foo = Environment(ENV = ENV)
 latex = foo.Dictionary('LATEX')
 makeindex = foo.Dictionary('MAKEINDEX')
+python_path = r'%(_python_)s'
 bar = Environment(ENV = ENV,
-                  LATEX = r'%(_python_)s wrapper.py ' + latex,
-                  MAKEINDEX =  r' wrapper.py ' + makeindex)
+                  LATEX = python_path + ' wrapper.py ' + latex,
+                  MAKEINDEX =  python_path + ' wrapper.py ' + makeindex)
 foo.DVI(target = 'foo.dvi', source = 'foo.ltx')
 bar.DVI(target = 'bar', source = 'bar.latex')
 
@@ -130,7 +133,7 @@
 """
 
     makeindex =  r"""
-\documentclass{letter}
+\documentclass{report}
 \usepackage{makeidx}
 \makeindex
 \begin{document}
@@ -141,7 +144,7 @@
 """
 
     latex1 = r"""
-\documentclass{letter}
+\documentclass{report}
 \usepackage{makeidx}
 \makeindex
 \begin{document}
Index: src/engine/SCons/Scanner/LaTeX.py
===================================================================
--- src/engine/SCons/Scanner/LaTeX.py	(revision 2970)
+++ src/engine/SCons/Scanner/LaTeX.py	(working copy)
@@ -31,19 +31,33 @@
 
 import os.path
 import string
+import re
 
 import SCons.Scanner
 
 def LaTeXScanner():
-    """Return a prototype Scanner instance for scanning LaTeX source files"""
+    """Return a prototype Scanner instance for scanning LaTeX source files
+    when built with latex.
+    """
     ds = LaTeX(name = "LaTeXScanner",
                suffixes =  '$LATEXSUFFIXES',
-               path_variable = 'TEXINPUTS',
-               regex = '\\\\(include|includegraphics(?:\[[^\]]+\])?|input|bibliography|usepackage){([^}]*)}',
+               # in the search order, see below in LaTeX class docstring
+               graphics_extensions = ['.eps', '.ps'],
                recursive = 0)
     return ds
 
-class LaTeX(SCons.Scanner.Classic):
+def PDFLaTeXScanner():
+    """Return a prototype Scanner instance for scanning LaTeX source files
+    when built with pdflatex.
+    """
+    ds = LaTeX(name = "PDFLaTeXScanner",
+               suffixes =  '$LATEXSUFFIXES',
+               # in the search order, see below in LaTeX class docstring
+               graphics_extensions = ['.png', '.pdf', '.jpg', '.tif'],
+               recursive = 0)
+    return ds
+
+class LaTeX(SCons.Scanner.Base):
     """Class for scanning LaTeX files for included files.
 
     Unlike most scanners, which use regular expressions that just
@@ -51,76 +65,191 @@
     of the keyword for the inclusion ("include", "includegraphics",
     "input", or "bibliography"), and then the file name itself.  
     Based on a quick look at LaTeX documentation, it seems that we 
-    need a should append .tex suffix for the "include" keywords, 
-    append .tex if there is no extension for the "input" keyword, 
-    but leave the file name untouched for "includegraphics." For
-    the "bibliography" keyword we need to add .bib if there is
-    no extension. (This need to be revisited since if there
-    is no extension for an "includegraphics" keyword latex will 
-    append .ps or .eps to find the file; while pdftex will use 
-    other extensions.)
+    should append .tex suffix for the "include" keywords, append .tex if
+    there is no extension for the "input" keyword, and need to add .bib
+    for the "bibliography" keyword that does not accept extensions by itself.
+
+    Finally, if there is no extension for an "includegraphics" keyword
+    latex will append .ps or .eps to find the file, while pdftex may use .pdf,
+    .jpg, .tif, .mps, or .png.
+    
+    The actual subset and search order may be altered by
+    DeclareGraphicsExtensions command. This complication is ignored.
+    The default order corresponds to experimentation with teTeX
+        $ latex --version
+        pdfeTeX 3.141592-1.21a-2.2 (Web2C 7.5.4)
+        kpathsea version 3.5.4
+    The order is:
+        ['.eps', '.ps'] for latex
+        ['.png', '.pdf', '.jpg', '.tif'].
+
+    Another difference is that the search path is determined by the type
+    of the file being searched:
+    env['TEXINPUTS'] for "input" and "include" keywords
+    env['TEXPICTS'] for "includegraphics" keyword
+    env['BIBINPUTS'] for "bibliography" keyword
+    env['BSTINPUTS'] for "bibliographystyle" keyword
+
+    FIXME: also look for the class or style in document[class|style]{}
+    FIXME: also look for the argument of bibliographystyle{}
     """
-    def latex_name(self, include):
+    keyword_paths = {'include': 'TEXINPUTS',
+                     'input': 'TEXINPUTS',
+                     'includegraphics': 'TEXPICTS',
+                     'bibliography': 'BIBINPUTS',
+                     'bibliographystyle': 'BSTINPUTS',
+                     'usepackage': 'TEXINPUTS'}
+    env_variables = SCons.Util.unique(keyword_paths.values())
+
+    def __init__(self, name, suffixes, graphics_extensions, *args, **kw):
+
+        regex = '\\\\(include|includegraphics(?:\[[^\]]+\])?|input|bibliography|usepackage){([^}]*)}'
+        self.cre = re.compile(regex, re.M)
+        self.graphics_extensions = graphics_extensions
+
+        def _scan(node, env, path=(), self=self):
+            node = node.rfile()
+            if not node.exists():
+                return []
+            return self.scan(node, path)
+
+        class FindMultiPathDirs:
+            """The stock FindPathDirs function has the wrong granularity:
+            it is called once per target, while we need the path that depends
+            on what kind of included files is being searched. This wrapper
+            hides multiple instances of FindPathDirs, one per the LaTeX path
+            variable in the environment. When invoked, the function calculates
+            and returns all the required paths as a dictionary (converted into
+            a tuple to become hashable). Then the scan function converts it
+            back and uses a dictionary of tuples rather than a single tuple
+            of paths.
+            """
+            def __init__(self, dictionary):
+                self.dictionary = {}
+                for k, n  in dictionary.iteritems():
+                    self.dictionary[k] = SCons.Scanner.FindPathDirs(n)
+            def __call__(self, env, dir=None, target=None, source=None, argument=None):
+                di = {}
+                for k, c  in self.dictionary.iteritems():
+                    p = c(env, dir=None, target=None, source=None, argument=None)
+                    di[k] = p
+                # To prevent "dict is not hashable error"
+                rv = tuple([(k,v) for k, v in di.iteritems()])
+                return rv
+
+        class LaTeXScanCheck:
+            """Skip all but LaTeX source files, i.e., do not scan *.eps,
+            *.pdf, *.jpg, etc.
+            """
+            def __init__(self, suffixes):
+                self.suffixes = suffixes
+            def __call__(self, node, env):
+                current = not node.has_builder() or node.is_up_to_date()
+                scannable = node.get_suffix() in env.subst(self.suffixes)
+                # Returning false means that the file is not scanned.
+                return scannable and current
+
+        kw['function'] = _scan
+        kw['path_function'] = FindMultiPathDirs(LaTeX.keyword_paths)
+        kw['recursive'] = 1
+        kw['skeys'] = suffixes
+        kw['scan_check'] = LaTeXScanCheck(suffixes)
+        kw['name'] = name
+
+        apply(SCons.Scanner.Base.__init__, (self,) + args, kw)
+
+    def _latex_names(self, include):
         filename = include[1]
         if include[0] == 'input':
             base, ext = os.path.splitext( filename )
             if ext == "":
-                filename = filename + '.tex'
+                return [filename + '.tex']
         if (include[0] == 'include'):
-            filename = filename + '.tex'
+            return [filename + '.tex']
         if include[0] == 'bibliography':
             base, ext = os.path.splitext( filename )
             if ext == "":
-                filename = filename + '.bib'
+                return [filename + '.bib']
         if include[0] == 'usepackage':
             base, ext = os.path.splitext( filename )
             if ext == "":
-                filename = filename + '.sty'
-        return filename
+                return [filename + '.sty']
+        if include[0] == 'includegraphics':
+            base, ext = os.path.splitext( filename )
+            if ext == "":
+                return [filename + e for e in self.graphics_extensions]
+        return [filename]
+
     def sort_key(self, include):
-        return SCons.Node.FS._my_normcase(self.latex_name(include))
+        return SCons.Node.FS._my_normcase(str(include))
+
     def find_include(self, include, source_dir, path):
-        i = SCons.Node.FS.find_file(self.latex_name(include),
-                                    (source_dir,) + path)
+        try:
+            sub_path = path[include[0]]
+        except:
+            sub_path = ()
+        try_names = self._latex_names(include)
+        for n in try_names:
+            i = SCons.Node.FS.find_file(n, (source_dir,) + sub_path)
+            if i:
+                return i, include
         return i, include
 
     def scan(self, node, path=()):
-        #
         # Modify the default scan function to allow for the regular
         # expression to return a comma separated list of file names
         # as can be the case with the bibliography keyword.
-        #
-        # cache the includes list in node so we only scan it once:
+
+        # Cache the includes list in node so we only scan it once:
+        path_dict = dict(list(path))
+        noopt_cre = re.compile('\[.*$')
         if node.includes != None:
             includes = node.includes
         else:
             includes = self.cre.findall(node.get_contents())
+            # 1. Split comma-separated lines, e.g.
+            #      ('bibliography', 'phys,comp')
+            #    should become two entries
+            #      ('bibliography', 'phys')
+            #      ('bibliography', 'comp')
+            # 2. Remove the options, e.g., such as
+            #      ('includegraphics[clip,width=0.7\\linewidth]', 'picture.eps')
+            #    should become
+            #      ('includegraphics', 'picture.eps')
+            split_includes = []
+            for include in includes:
+                inc_type = noopt_cre.sub('', include[0])
+                inc_list = string.split(include[1],',')
+                for j in range(len(inc_list)):
+                    split_includes.append( (inc_type, inc_list[j]) )
+            #
+            includes = split_includes
             node.includes = includes
 
         # This is a hand-coded DSU (decorate-sort-undecorate, or
         # Schwartzian transform) pattern.  The sort key is the raw name
-        # of the file as specifed on the #include line (including the
-        # " or <, since that may affect what file is found), which lets
+        # of the file as specifed on the \include, \input, etc. line.
+        # TODO: what about the comment in the original Classic scanner:
+        # """which lets
         # us keep the sort order constant regardless of whether the file
-        # is actually found in a Repository or locally.
+        # is actually found in a Repository or locally."""
         nodes = []
         source_dir = node.get_dir()
         for include in includes:
             #
             # Handle multiple filenames in include[1]
             #
-            inc_list = string.split(include[1],',')
-            for j in range(len(inc_list)):
-                include_local = [include[0],inc_list[j]]
-                n, i = self.find_include(include_local, source_dir, path)
-
+            n, i = self.find_include(include, source_dir, path_dict)
             if n is None:
-                SCons.Warnings.warn(SCons.Warnings.DependencyWarning,
-                                    "No dependency generated for file: %s (included from: %s) -- file not found" % (i, node))
+                # Do not bother with 'usepackage' warnings, as they most
+                # likely refer to system-level files
+                if include[0] != 'usepackage':
+                    SCons.Warnings.warn(SCons.Warnings.DependencyWarning,
+                                        "No dependency generated for file: %s (included from: %s) -- file not found" % (i, node))
             else:
-                sortkey = self.sort_key(include)
+                sortkey = self.sort_key(n)
                 nodes.append((sortkey, n))
-
+        #
         nodes.sort()
         nodes = map(lambda pair: pair[1], nodes)
         return nodes
Index: src/engine/SCons/Tool/__init__.py
===================================================================
--- src/engine/SCons/Tool/__init__.py	(revision 2970)
+++ src/engine/SCons/Tool/__init__.py	(working copy)
@@ -55,6 +55,7 @@
 CScanner = SCons.Scanner.C.CScanner()
 DScanner = SCons.Scanner.D.DScanner()
 LaTeXScanner = SCons.Scanner.LaTeX.LaTeXScanner()
+PDFLaTeXScanner = SCons.Scanner.LaTeX.PDFLaTeXScanner()
 ProgramScanner = SCons.Scanner.Prog.ProgramScanner()
 SourceFileScanner = SCons.Scanner.Base({}, name='SourceFileScanner')
 
@@ -76,8 +77,11 @@
 for suffix in DSuffixes:
     SourceFileScanner.add_scanner(suffix, DScanner)
 
+# FIXME: what should be done here? Two scanners scan the same extensions,
+# but look for different files, e.g., "picture.eps" vs. "picture.pdf".
 for suffix in LaTeXSuffixes:
-     SourceFileScanner.add_scanner(suffix, LaTeXScanner)
+    SourceFileScanner.add_scanner(suffix, LaTeXScanner)
+#    SourceFileScanner.add_scanner(suffix, PDFLaTeXScanner)
 
 class Tool:
     def __init__(self, name, toolpath=[], **kw):
Index: src/engine/SCons/Tool/pdf.py
===================================================================
--- src/engine/SCons/Tool/pdf.py	(revision 2970)
+++ src/engine/SCons/Tool/pdf.py	(working copy)
@@ -41,7 +41,7 @@
         global PDFBuilder
         if PDFBuilder is None:
             PDFBuilder = SCons.Builder.Builder(action = {},
-                                               source_scanner = SCons.Tool.LaTeXScanner,
+                                               source_scanner = SCons.Tool.PDFLaTeXScanner,
                                                prefix = '$PDFPREFIX',
                                                suffix = '$PDFSUFFIX',
                                                emitter = {},
Index: src/engine/SCons/Tool/pdftex.py
===================================================================
--- src/engine/SCons/Tool/pdftex.py	(revision 2970)
+++ src/engine/SCons/Tool/pdftex.py	(working copy)
@@ -44,17 +44,18 @@
 PDFLaTeXAction = None
 
 def PDFLaTeXAuxAction(target = None, source= None, env=None):
-    SCons.Tool.tex.InternalLaTeXAuxAction( PDFLaTeXAction, target, source, env )
+    result = SCons.Tool.tex.InternalLaTeXAuxAction( PDFLaTeXAction, target, source, env )
+    return result
 
 def PDFTeXLaTeXFunction(target = None, source= None, env=None):
     """A builder for TeX and LaTeX that scans the source file to
     decide the "flavor" of the source and then executes the appropriate
     program."""
     if SCons.Tool.tex.is_LaTeX(source):
-        PDFLaTeXAuxAction(target,source,env)
+        result = PDFLaTeXAuxAction(target,source,env)
     else:
-        PDFTeXAction(target,source,env)
-    return 0
+        result = PDFTeXAction(target,source,env)
+    return result
 
 PDFTeXLaTeXAction = None
 
@@ -71,7 +72,7 @@
     global PDFTeXLaTeXAction
     if PDFTeXLaTeXAction is None:
         PDFTeXLaTeXAction = SCons.Action.Action(PDFTeXLaTeXFunction,
-                                                strfunction=None)
+                                                ' ')
 
     import pdf
     pdf.generate(env)
Index: src/engine/SCons/Tool/pdflatex.py
===================================================================
--- src/engine/SCons/Tool/pdflatex.py	(revision 2970)
+++ src/engine/SCons/Tool/pdflatex.py	(working copy)
@@ -9,7 +9,7 @@
 """
 
 #
-# __COPYRIGHT__
+# Copyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007 The SCons Foundation
 #
 # Permission is hereby granted, free of charge, to any person obtaining
 # a copy of this software and associated documentation files (the
@@ -31,7 +31,7 @@
 # WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #
 
-__revision__ = "__FILE__ __REVISION__ __DATE__ __DEVELOPER__"
+__revision__ = "src/engine/SCons/Tool/pdflatex.py 2611 2008/01/29 11:58:38 managan"
 
 import SCons.Action
 import SCons.Util
@@ -41,7 +41,8 @@
 PDFLaTeXAction = None
 
 def PDFLaTeXAuxFunction(target = None, source= None, env=None):
-    SCons.Tool.tex.InternalLaTeXAuxAction( PDFLaTeXAction, target, source, env )
+    result = SCons.Tool.tex.InternalLaTeXAuxAction( PDFLaTeXAction, target, source, env )
+    return result
 
 PDFLaTeXAuxAction = None
 
@@ -54,7 +55,7 @@
     global PDFLaTeXAuxAction
     if PDFLaTeXAuxAction is None:
         PDFLaTeXAuxAction = SCons.Action.Action(PDFLaTeXAuxFunction,
-                                                strfunction=None)
+                                                ' ')
 
     import pdf
     pdf.generate(env)
@@ -66,7 +67,7 @@
     bld.add_emitter('.latex', SCons.Tool.tex.tex_emitter)
 
     env['PDFLATEX']      = 'pdflatex'
-    env['PDFLATEXFLAGS'] = SCons.Util.CLVar('')
+    env['PDFLATEXFLAGS'] = SCons.Util.CLVar('-interaction=nonstopmode')
     env['PDFLATEXCOM']   = 'cd ${TARGET.dir} && $PDFLATEX $PDFLATEXFLAGS ${SOURCE.file}'
     env['LATEXRETRIES']  = 3
 
Index: src/engine/SCons/Tool/tex.py
===================================================================
--- src/engine/SCons/Tool/tex.py	(revision 2970)
+++ src/engine/SCons/Tool/tex.py	(working copy)
@@ -9,7 +9,7 @@
 """
 
 #
-# __COPYRIGHT__
+# Copyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007 The SCons Foundation
 #
 # Permission is hereby granted, free of charge, to any person obtaining
 # a copy of this software and associated documentation files (the
@@ -31,17 +31,21 @@
 # WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #
 
-__revision__ = "__FILE__ __REVISION__ __DATE__ __DEVELOPER__"
+__revision__ = "src/engine/SCons/Tool/tex.py 2611 2008/01/29 11:58:38 managan"
 
 import os.path
 import re
 import string
+import shutil
 
 import SCons.Action
 import SCons.Node
 import SCons.Node.FS
 import SCons.Util
-
+#
+# regular expressions used to search for Latex features
+# or outputs that require rerunning latex
+#
 warning_rerun_re = re.compile('(^LaTeX Warning:.*Rerun)|(^Package \w+ Warning:.*Rerun)', re.MULTILINE)
 
 rerun_citations_str = "^LaTeX Warning:.*\n.*Rerun to get citations correct"
@@ -54,8 +58,11 @@
 openout_re = re.compile(r"\\openout.*`(.*)'")
 
 makeindex_re = re.compile(r"^[^%]*\\makeindex", re.MULTILINE)
+index_re = re.compile(r"^[^%]*\\index", re.MULTILINE)
 tableofcontents_re = re.compile(r"^[^%]*\\tableofcontents", re.MULTILINE)
 bibliography_re = re.compile(r"^[^%]*\\bibliography", re.MULTILINE)
+listoffigures_re = re.compile(r"^[^%]*\\listoffigures", re.MULTILINE)
+hyperref_re = re.compile(r"^[^%]*\\usepackage.*\{hyperref\}", re.MULTILINE)
 
 # An Action sufficient to build any generic tex file.
 TeXAction = None
@@ -70,6 +77,37 @@
 # An action to run MakeIndex on a file.
 MakeIndexAction = None
 
+# Used as a return value of modify_env_var if the variable is not set.
+class _Null:
+    pass
+_null = _Null
+
+# The user specifies the paths in env[variable], similar to other builders.
+# They may be relative and must be converted to absolute, as expected
+# by LaTeX and Co. The environment may already have some paths in
+# env['ENV'][var]. These paths are honored, by the env[var] paths have
+# higher precedence. All changes are un-done on exit.
+def modify_env_var(env, var):
+    try:
+        save = env['ENV'][var]
+    except KeyError:
+        save = _null
+    try:
+        if SCons.Util.is_List(env[var]):
+            env.PrependENVPath(var, [os.path.abspath(str(p)) for p in env[var]])
+        else:
+            # Split at os.pathsep to convert into absolute path
+            env.PrependENVPath(var, [os.path.abspath(p) for p in str(env[var]).split(os.pathsep)])
+        # Convert into a string explicitly to append ":" (to search system
+        # paths as well). The problem is that env.AppendENVPath(var, ":")
+        # does not work, refuses to append ":" (os.pathsep).
+        if SCons.Util.is_List(env['ENV'][var]):
+            env['ENV'][var] = os.pathsep.join(env['ENV'][var])
+        env['ENV'][var] = env['ENV'][var] + ":"
+    except KeyError:
+        pass
+    return save
+
 def InternalLaTeXAuxAction(XXXLaTeXAction, target = None, source= None, env=None):
     """A builder for LaTeX files that checks the output in the aux file
     and decides how many times to use LaTeXAction, and BibTeXAction."""
@@ -78,30 +116,13 @@
     basedir = os.path.split(str(source[0]))[0]
     basefile = os.path.split(str(basename))[1]
     abspath = os.path.abspath(basedir)
-    targetbase = SCons.Util.splitext(str(target[0]))[0]
+    targetext = os.path.splitext(str(target[0]))[1]
     targetdir = os.path.split(str(target[0]))[0]
 
-    # Not sure if these environment changes should go here or make the
-    # user do them I undo all but TEXPICTS but there is still the side
-    # effect of creating the empty (':') entries in the environment.
+    saved_env = {}
+    for var in SCons.Scanner.LaTeX.LaTeX.env_variables:
+        saved_env[var] = modify_env_var(env, var)
 
-    def modify_env_var(env, var, abspath):
-        try:
-            save = env['ENV'][var]
-        except KeyError:
-            save = ':'
-            env['ENV'][var] = ''
-        if SCons.Util.is_List(env['ENV'][var]):
-            env['ENV'][var] = [abspath] + env['ENV'][var]
-        else:
-            env['ENV'][var] = abspath + os.pathsep + env['ENV'][var]
-        return save
-
-    texinputs_save = modify_env_var(env, 'TEXINPUTS', abspath)
-    bibinputs_save = modify_env_var(env, 'BIBINPUTS', abspath)
-    bstinputs_save = modify_env_var(env, 'BSTINPUTS', abspath)
-    texpicts_save = modify_env_var(env, 'TEXPICTS', abspath)
-
     # Create these file names with the target directory since they will
     # be made there.   That's because the *COM variables have the cd
     # command in the prolog.
@@ -121,8 +142,23 @@
     if os.path.exists(tocfilename):
         tocContents = open(tocfilename, "rb").read()
 
+    loffilename = os.path.join(targetdir, basefile + '.lof')
+    lofContents = ""
+    if os.path.exists(loffilename):
+        lofContents = open(loffilename, "rb").read()
+
+    outfilename = os.path.join(targetdir, basefile + '.out')
+    outContents = ""
+    if os.path.exists(outfilename):
+        outContents = open(outfilename, "rb").read()
+
+    # generate the file name that latex will generate
+    resultfilename = os.path.join(targetdir, basefile + targetext)
+
     # Run LaTeX once to generate a new aux file and log file.
-    XXXLaTeXAction(target, source, env)
+    result = XXXLaTeXAction(target, source, env)
+    if result != 0:
+        return result
 
     # Decide if various things need to be run, or run again.  We check
     # for the existence of files before opening them--even ones like the
@@ -130,7 +166,7 @@
     # with stubs that don't necessarily generate all of the same files.
 
     # Read the log file to find all .aux files
-    logfilename = os.path.join(targetbase + '.log')
+    logfilename = os.path.join(targetdir,basefile + '.log')
     auxfiles = []
     if os.path.exists(logfilename):
         content = open(logfilename, "rb").read()
@@ -142,8 +178,10 @@
         if os.path.exists(target_aux):
             content = open(target_aux, "rb").read()
             if string.find(content, "bibdata") != -1:
-                bibfile = env.fs.File(targetbase)
-                BibTeXAction(bibfile, bibfile, env)
+                bibfile = env.fs.File(os.path.join(targetdir,basefile))
+                result = BibTeXAction(bibfile, bibfile, env)
+                if result != 0:
+                    return result
                 break
 
     must_rerun_latex = 0
@@ -158,15 +196,26 @@
     # Now decide if latex will need to be run again due to index.
     if os.path.exists(idxfilename) and idxContents != open(idxfilename, "rb").read():
         # We must run makeindex
-        idxfile = env.fs.File(targetbase)
-        MakeIndexAction(idxfile, idxfile, env)
+        idxfile = env.fs.File(os.path.join(targetdir,basefile))
+        result = MakeIndexAction(idxfile, idxfile, env)
+        if result != 0:
+            return result
         must_rerun_latex = 1
 
+    # Now decide if latex will need to be run again due to list of figures.
+    if os.path.exists(loffilename) and lofContents != open(loffilename, "rb").read():
+        must_rerun_latex = 1
+
+    # Now decide if latex will need to be run again due to hyperref bookmarks
+    if os.path.exists(outfilename) and outContents != open(outfilename, "rb").read():
+        must_rerun_latex = 1
+
     if must_rerun_latex == 1:
-        XXXLaTeXAction(target, source, env)
+        result = XXXLaTeXAction(target, source, env)
+        if result != 0:
+            return result
 
     # Now decide if latex needs to be run yet again to resolve warnings.
-    logfilename = targetbase + '.log'
     for _ in range(int(env.subst('$LATEXRETRIES'))):
         if not os.path.exists(logfilename):
             break
@@ -175,20 +224,49 @@
            not rerun_citations_re.search(content) and \
            not undefined_references_re.search(content):
             break
-        XXXLaTeXAction(target, source, env)
+        result = XXXLaTeXAction(target, source, env)
+        if result != 0:
+            return result
 
-    env['ENV']['TEXINPUTS'] = texinputs_save
-    env['ENV']['BIBINPUTS'] = bibinputs_save
-    env['ENV']['BSTINPUTS'] = bibinputs_save
-
+    # rename Latex's output to what the target name is
+    if not (str(target[0]) == resultfilename  and  os.path.exists(resultfilename)):
+        if os.path.exists(resultfilename):
+            print "move %s to %s" % (resultfilename, str(target[0]), )
+            shutil.move(resultfilename,str(target[0]))
+        # if the user gave some other extension try  PDFSUFFIX and then .dvi
+        # not sure how to tell if we got here from a PDF or DVI builder.
+        else:
+            for ext in [env['PDFSUFFIX'],'.dvi']:
+                resultfilename = os.path.splitext(resultfilename)[0] + ext
+                if os.path.exists(resultfilename):
+                    print "move %s to %s" % (resultfilename, str(target[0]), )
+                    shutil.move(resultfilename,str(target[0]))
+                    break
+    
+    # Original comment (when TEXPICTS was not restored):
     # The TEXPICTS enviroment variable is needed by a dvi -> pdf step
-    # later on Mac OSX so leave it,
-    # env['ENV']['TEXPICTS']  = texpicts_save
+    # later on Mac OSX so leave it
+    #
+    # It is also used when searching for pictures (implicit dependencies).
+    # Why not set the variable again in the respective builder instead
+    # of leaving local modifications in the environment? What if multiple
+    # latex builds in different directories need different TEXPICTS?
+    for var in SCons.Scanner.LaTeX.LaTeX.env_variables:
+        if var == 'TEXPICTS':
+            continue
+        if saved_env[var] is _null:
+            try:
+                env['ENV'].pop(var)
+            except KeyError:
+                pass # was never set
+        else:
+            env['ENV'][var] = saved_env[var]
 
-    return 0
+    return result
 
 def LaTeXAuxAction(target = None, source= None, env=None):
-    InternalLaTeXAuxAction( LaTeXAction, target, source, env )
+    result = InternalLaTeXAuxAction( LaTeXAction, target, source, env )
+    return result
 
 LaTeX_re = re.compile("\\\\document(style|class)")
 
@@ -205,48 +283,123 @@
     decide the "flavor" of the source and then executes the appropriate
     program."""
     if is_LaTeX(source):
-        LaTeXAuxAction(target,source,env)
+        result = LaTeXAuxAction(target,source,env)
     else:
-        TeXAction(target,source,env)
-    return 0
+        result = TeXAction(target,source,env)
+    return result
 
 def tex_emitter(target, source, env):
-    base = SCons.Util.splitext(str(source[0]))[0]
+    """An emitter for TeX and LaTeX sources. 
+    For LaTeX sources we try and find the common created files that
+    are needed on subsequent runs of latex to finish tables of contents,
+    bibliographies, indices, lists of figures, and hyperlink references.
+    """
     targetbase = SCons.Util.splitext(str(target[0]))[0]
+    basename = SCons.Util.splitext(str(source[0]))[0]
+    basefile = os.path.split(str(basename))[1]
+    
+    #
+    # file names we will make use of in searching the sources and log file
+    #
+    auxfilename = targetbase + '.aux'
+    tocfilename = targetbase + '.toc'
+    idxfilename = targetbase + '.idx'
+    indfilename = targetbase + '.ind'
+    ilgfilename = targetbase + '.ilg'
+    bblfilename = targetbase + '.bbl'
+    blgfilename = targetbase + '.blg'
+    loffilename = targetbase + '.lof'
+    outfilename = targetbase + '.out'
+    logfilename = targetbase + '.log'
 
-    target.append(targetbase + '.aux')
-    env.Precious(targetbase + '.aux')
-    target.append(targetbase + '.log')
+    env.SideEffect(auxfilename,target[0])
+#    target.append(auxfilename)
+#    env.Precious(auxfilename)
+    env.SideEffect(logfilename,target[0])
+#    target.append(logfilename)
     for f in source:
         content = f.get_contents()
+        # even with no sections or chapters \tableofcontents generates an empty .toc file
         if tableofcontents_re.search(content):
-            target.append(targetbase + '.toc')
-            env.Precious(targetbase + '.toc')
+            env.SideEffect(tocfilename,target[0])
+#            target.append(tocfilename)
+#            env.Precious(tocfilename)
+
+        # \makeindex by itself generates empty .idx file
+        # \printindex by itself does nothing, \index by itself does nothing
+        # \printindex \index by themselves do nothing
+        # \makeindex & \index causes makeindex run and generates .idx, .ilg, & .ind files
+        # \makeindex & \printindex generates empty .idx file; makeindex not run
         if makeindex_re.search(content):
-            target.append(targetbase + '.ilg')
-            target.append(targetbase + '.ind')
-            target.append(targetbase + '.idx')
-            env.Precious(targetbase + '.idx')
+            env.SideEffect(idxfilename,target[0])
+#            target.append(idxfilename)
+#            env.Precious(idxfilename)
+        if (makeindex_re.search(content) and index_re.search(content)):
+            env.SideEffect(indfilename,target[0])
+            env.SideEffect(ilgfilename,target[0])
+#            target.append(indfilename)
+#            env.Precious(indfilename)
+#            target.append(ilgfilename)
+#            env.Precious(ilgfilename)
+
+        # \bibliography by itself generates empty .bbl file, nonempty .blg file, errors for no \cite, \bibstyle
+        # \bibliographystyle by itself generates nothing, bibtex not run
+        # \cite by itself generates nothing, bibtex not run, latex reruns to limit
+        # \bibliographystyle & \cite by themselves generates nothing, bibtex not run, latex reruns to limit
+        # \bibliography & \bibliographystyle by themselves generates .bbl file, & .blg file, errors for no \cite
         if bibliography_re.search(content):
-            target.append(targetbase + '.bbl')
-            env.Precious(targetbase + '.bbl')
-            target.append(targetbase + '.blg')
+            env.SideEffect(bblfilename,target[0])
+#            target.append(bblfilename)
+#            env.Precious(bblfilename)
+            env.SideEffect(blgfilename,target[0])
+#            target.append(blgfilename)
+#            env.Precious(blgfilename)
 
-    # read log file to get all .aux files
-    logfilename = targetbase + '.log'
-    dir, base_nodir = os.path.split(targetbase)
+        # even with no figures \listoffigures generates an empty .lof file
+        # It takes a \begin{figure} with \caption to get nonempty .lof
+        if listoffigures_re.search(content):
+            env.SideEffect(loffilename,target[0])
+#            target.append(loffilename)
+#            env.Precious(loffilename)
+
+        # even with no sections or chapters \usepackage{hyperref} generates an empty .out file
+        if hyperref_re.search(content):
+            env.SideEffect(outfilename,target[0])
+#            target.append(outfilename)
+#            env.Precious(outfilename)
+
+    # read log file to get all other files that latex creates and will read on the next pass
     if os.path.exists(logfilename):
         content = open(logfilename, "rb").read()
         out_files = openout_re.findall(content)
-        out_files = filter(lambda f, b=base_nodir+'.aux': f != b, out_files)
-        if dir != '':
-            out_files = map(lambda f, d=dir: d+os.sep+f, out_files)
-        target.extend(out_files)
-        for f in out_files:
-            env.Precious( f )
+        # remove files from list that we have already added to the target list
+        # remove the .aux file from the list
+        out_files = filter(lambda f, b=basefile + '.aux': f != b, out_files)
+        # remove the .toc file from the list
+        out_files = filter(lambda f, b=basefile + '.toc': f != b, out_files)
+        # remove the .idx file from the list
+        out_files = filter(lambda f, b=basefile + '.idx': f != b, out_files)
+        # remove the .ind file from the list
+        out_files = filter(lambda f, b=basefile + '.ind': f != b, out_files)
+        # remove the .ilg file from the list
+        out_files = filter(lambda f, b=basefile + '.ilg': f != b, out_files)
+        # remove the .bbl file from the list
+        out_files = filter(lambda f, b=basefile + '.bbl': f != b, out_files)
+        # remove the .blg file from the list
+        out_files = filter(lambda f, b=basefile + '.blg': f != b, out_files)
+        # remove the .lof file from the list
+        out_files = filter(lambda f, b=basefile + '.lof': f != b, out_files)
+        # remove the .out file from the list
+        out_files = filter(lambda f, b=basefile + '.out': f != b, out_files)
 
+        env.SideEffect(out_files,target[0])
+#        target.extend(out_files)
+#        for f in out_files:
+#            env.Precious( f )
+
     return (target, source)
 
+
 TeXLaTeXAction = None
 
 def generate(env):
@@ -275,7 +428,7 @@
 
     global TeXLaTeXAction
     if TeXLaTeXAction is None:
-        TeXLaTeXAction = SCons.Action.Action(TeXLaTeXFunction, strfunction=None)
+        TeXLaTeXAction = SCons.Action.Action(TeXLaTeXFunction, ' ')
 
     import dvi
     dvi.generate(env)
@@ -285,12 +438,12 @@
     bld.add_emitter('.tex', tex_emitter)
 
     env['TEX']      = 'tex'
-    env['TEXFLAGS'] = SCons.Util.CLVar('')
+    env['TEXFLAGS'] = SCons.Util.CLVar('-interaction=nonstopmode')
     env['TEXCOM']   = 'cd ${TARGET.dir} && $TEX $TEXFLAGS ${SOURCE.file}'
 
     # Duplicate from latex.py.  If latex.py goes away, then this is still OK.
     env['LATEX']        = 'latex'
-    env['LATEXFLAGS']   = SCons.Util.CLVar('')
+    env['LATEXFLAGS']   = SCons.Util.CLVar('-interaction=nonstopmode')
     env['LATEXCOM']     = 'cd ${TARGET.dir} && $LATEX $LATEXFLAGS ${SOURCE.file}'
     env['LATEXRETRIES'] = 3
 
@@ -302,5 +455,11 @@
     env['MAKEINDEXFLAGS'] = SCons.Util.CLVar('')
     env['MAKEINDEXCOM']   = 'cd ${TARGET.dir} && $MAKEINDEX $MAKEINDEXFLAGS ${SOURCE.file}'
 
+    # Duplicate from pdflatex.py.  If latex.py goes away, then this is still OK.
+    env['PDFLATEX']      = 'pdflatex'
+    env['PDFLATEXFLAGS'] = SCons.Util.CLVar('-interaction=nonstopmode')
+    env['PDFLATEXCOM']   = 'cd ${TARGET.dir} && $PDFLATEX $PDFLATEXFLAGS ${SOURCE.file}'
+    env['LATEXRETRIES']  = 3
+
 def exists(env):
     return env.Detect('tex')
Index: src/engine/SCons/Tool/latex.py
===================================================================
--- src/engine/SCons/Tool/latex.py	(revision 2970)
+++ src/engine/SCons/Tool/latex.py	(working copy)
@@ -9,7 +9,7 @@
 """
 
 #
-# __COPYRIGHT__
+# Copyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007 The SCons Foundation
 #
 # Permission is hereby granted, free of charge, to any person obtaining
 # a copy of this software and associated documentation files (the
@@ -31,7 +31,7 @@
 # WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #
 
-__revision__ = "__FILE__ __REVISION__ __DATE__ __DEVELOPER__"
+__revision__ = "src/engine/SCons/Tool/latex.py 2611 2008/01/29 11:58:38 managan"
 
 import SCons.Action
 import SCons.Defaults
@@ -43,9 +43,10 @@
 LaTeXAction = None
 
 def LaTeXAuxFunction(target = None, source= None, env=None):
-    SCons.Tool.tex.InternalLaTeXAuxAction( LaTeXAction, target, source, env )
+    result = SCons.Tool.tex.InternalLaTeXAuxAction( LaTeXAction, target, source, env )
+    return result
 
-LaTeXAuxAction = SCons.Action.Action(LaTeXAuxFunction, strfunction=None)
+LaTeXAuxAction = SCons.Action.Action(LaTeXAuxFunction, ' ')
 
 def generate(env):
     """Add Builders and construction variables for LaTeX to an Environment."""
@@ -63,7 +64,7 @@
     bld.add_emitter('.latex', SCons.Tool.tex.tex_emitter)
 
     env['LATEX']        = 'latex'
-    env['LATEXFLAGS']   = SCons.Util.CLVar('')
+    env['LATEXFLAGS']   = SCons.Util.CLVar('-interaction=nonstopmode')
     env['LATEXCOM']     = 'cd ${TARGET.dir} && $LATEX $LATEXFLAGS ${SOURCE.file}'
     env['LATEXRETRIES'] = 3
 
